#!/usr/bin/env node
/*
Dumps CREATE TABLE statements for each table in the database into dbTables/<table>.sql
Usage: node scripts/dump_db_tables.js
It reads DB connection params from ../db.js (reuses pool) or from env vars.
*/
const fs = require('fs');
const path = require('path');
const dbPath = path.resolve(__dirname, '..', 'db.js');
let poolModule = null;
try { poolModule = require(dbPath); } catch (e) { poolModule = null; }

async function makePool() {
  if (poolModule && poolModule.pool) return poolModule.pool;
  // fallback: create a mysql2 pool from env
  const mysql = require('mysql2/promise');
  const pool = mysql.createPool({
    host: process.env.MYSQL_HOST || 'localhost',
    user: process.env.MYSQL_USER || 'root',
    password: process.env.MYSQL_PASS || '',
    database: process.env.MYSQL_DB || 'healthque',
    waitForConnections: true,
    connectionLimit: 5
  });
  return pool;
}

async function dump() {
  const pool = await makePool();
  const outDir = path.resolve(__dirname, '..', 'dbTables');
  if (!fs.existsSync(outDir)) fs.mkdirSync(outDir, { recursive: true });
  const [tables] = await pool.query("SHOW TABLES");
  const tableNames = [];
  if (Array.isArray(tables)) {
    // result shape: [ { 'Tables_in_dbname': 'table' }, ... ]
    for (const row of tables) {
      const keys = Object.keys(row);
      if (keys.length) tableNames.push(row[keys[0]]);
    }
  }
  for (const t of tableNames) {
    try {
      const [[createRow]] = await pool.query(`SHOW CREATE TABLE \`${t}\``).catch(e => [ [] ]);
      const createSql = createRow && (createRow['Create Table'] || createRow['Create View'] || createRow['Create Table']) ? (createRow['Create Table'] || createRow['Create View']) : null;
      const filename = path.join(outDir, `${t}.sql`);
      if (!createSql) {
        console.warn('Could not read CREATE statement for', t);
        continue;
      }
      const header = `-- Generated by scripts/dump_db_tables.js
-- Table: ${t}
-- Time: ${new Date().toISOString()}
\n`;
      const content = header + createSql + ';\n';
      let write = true;
      if (fs.existsSync(filename)) {
        const existing = fs.readFileSync(filename, 'utf8');
        if (existing.trim() === content.trim()) write = false;
      }
      if (write) {
        fs.writeFileSync(filename, content, 'utf8');
        console.log('Wrote', filename);
      } else {
        console.log('No change for', filename);
      }
    } catch (e) {
      console.error('Error dumping table', t, e && e.message);
    }
  }
  // close pool only if we created it manually
  if (!(poolModule && poolModule.pool)) await pool.end();
}

if (require.main === module) {
  dump().then(() => console.log('Dump complete')).catch(err => { console.error(err); process.exit(1); });
}

module.exports = { dump };
